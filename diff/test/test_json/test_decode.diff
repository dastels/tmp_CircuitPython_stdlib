--- <CPython-3.4.9>/test/test_json/test_decode.py
+++ lib/test/test_json/test_decode.py
@@ -1,15 +1,9 @@
-import decimal
 from io import StringIO, BytesIO
 from collections import OrderedDict
 from test.test_json import PyTest, CTest
 
 
 class TestDecode:
-    def test_decimal(self):
-        rval = self.loads('1.1', parse_float=decimal.Decimal)
-        self.assertTrue(isinstance(rval, decimal.Decimal))
-        self.assertEqual(rval, decimal.Decimal('1.1'))
-
     def test_float(self):
         rval = self.loads('1', parse_int=float)
         self.assertTrue(isinstance(rval, float))
@@ -77,23 +71,9 @@
         with self.assertRaisesRegex(TypeError, msg):
             self.json.load(BytesIO(b'[1,2,3]'))
 
-    def test_string_with_utf8_bom(self):
-        # see #18958
-        bom_json = "[1,2,3]".encode('utf-8-sig').decode('utf-8')
-        with self.assertRaises(ValueError) as cm:
-            self.loads(bom_json)
-        self.assertIn('BOM', str(cm.exception))
-        with self.assertRaises(ValueError) as cm:
-            self.json.load(StringIO(bom_json))
-        self.assertIn('BOM', str(cm.exception))
-        # make sure that the BOM is not detected in the middle of a string
-        bom_in_str = '"{}"'.format(''.encode('utf-8-sig').decode('utf-8'))
-        self.assertEqual(self.loads(bom_in_str), '\ufeff')
-        self.assertEqual(self.json.load(StringIO(bom_in_str)), '\ufeff')
-
     def test_negative_index(self):
         d = self.json.JSONDecoder()
         self.assertRaises(ValueError, d.raw_decode, 'a'*42, -50000)
 
 class TestPyDecode(TestDecode, PyTest): pass
-class TestCDecode(TestDecode, CTest): pass
+