--- <CPython-3.4.9>/logging/handlers.py
+++ lib/logging/handlers.py
@@ -23,24 +23,13 @@
 To use, simply 'import logging.handlers' and log away!
 """
 
-import logging, socket, os, pickle, struct, time, re
+import logging, os, time, re                                                    ###
 from stat import ST_DEV, ST_INO, ST_MTIME
-import queue
-try:
-    import threading
-except ImportError: #pragma: no cover
-    threading = None
 
 #
 # Some constants...
 #
 
-DEFAULT_TCP_LOGGING_PORT    = 9020
-DEFAULT_UDP_LOGGING_PORT    = 9021
-DEFAULT_HTTP_LOGGING_PORT   = 9022
-DEFAULT_SOAP_LOGGING_PORT   = 9023
-SYSLOG_UDP_PORT             = 514
-SYSLOG_TCP_PORT             = 514
 
 _MIDNIGHT = 24 * 60 * 60  # number of seconds in a day
 
@@ -244,7 +233,7 @@
         else:
             raise ValueError("Invalid rollover interval specified: %s" % self.when)
 
-        self.extMatch = re.compile(self.extMatch, re.ASCII)
+        self.extMatch = re.compile(self.extMatch)                               ###
         self.interval = self.interval * interval # multiply by units requested
         if os.path.exists(filename):
             t = os.stat(filename)[ST_MTIME]
@@ -410,760 +399,6 @@
                 newRolloverAt += addend
         self.rolloverAt = newRolloverAt
 
-class WatchedFileHandler(logging.FileHandler):
-    """
-    A handler for logging to a file, which watches the file
-    to see if it has changed while in use. This can happen because of
-    usage of programs such as newsyslog and logrotate which perform
-    log file rotation. This handler, intended for use under Unix,
-    watches the file to see if it has changed since the last emit.
-    (A file has changed if its device or inode have changed.)
-    If it has changed, the old file stream is closed, and the file
-    opened to get a new stream.
-
-    This handler is not appropriate for use under Windows, because
-    under Windows open files cannot be moved or renamed - logging
-    opens the files with exclusive locks - and so there is no need
-    for such a handler. Furthermore, ST_INO is not supported under
-    Windows; stat always returns zero for this value.
-
-    This handler is based on a suggestion and patch by Chad J.
-    Schroeder.
-    """
-    def __init__(self, filename, mode='a', encoding=None, delay=False):
-        logging.FileHandler.__init__(self, filename, mode, encoding, delay)
-        self.dev, self.ino = -1, -1
-        self._statstream()
-
-    def _statstream(self):
-        if self.stream:
-            sres = os.fstat(self.stream.fileno())
-            self.dev, self.ino = sres[ST_DEV], sres[ST_INO]
-
-    def emit(self, record):
-        """
-        Emit a record.
-
-        First check if the underlying file has changed, and if it
-        has, close the old stream and reopen the file to get the
-        current stream.
-        """
-        # Reduce the chance of race conditions by stat'ing by path only
-        # once and then fstat'ing our new fd if we opened a new log stream.
-        # See issue #14632: Thanks to John Mulligan for the problem report
-        # and patch.
-        try:
-            # stat the file by path, checking for existence
-            sres = os.stat(self.baseFilename)
-        except FileNotFoundError:
-            sres = None
-        # compare file system stat with that of our stream file handle
-        if not sres or sres[ST_DEV] != self.dev or sres[ST_INO] != self.ino:
-            if self.stream is not None:
-                # we have an open file handle, clean it up
-                self.stream.flush()
-                self.stream.close()
-                self.stream = None  # See Issue #21742: _open () might fail.
-                # open a new file handle and get new stat info from that fd
-                self.stream = self._open()
-                self._statstream()
-        logging.FileHandler.emit(self, record)
-
-
-class SocketHandler(logging.Handler):
-    """
-    A handler class which writes logging records, in pickle format, to
-    a streaming socket. The socket is kept open across logging calls.
-    If the peer resets it, an attempt is made to reconnect on the next call.
-    The pickle which is sent is that of the LogRecord's attribute dictionary
-    (__dict__), so that the receiver does not need to have the logging module
-    installed in order to process the logging event.
-
-    To unpickle the record at the receiving end into a LogRecord, use the
-    makeLogRecord function.
-    """
-
-    def __init__(self, host, port):
-        """
-        Initializes the handler with a specific host address and port.
-
-        When the attribute *closeOnError* is set to True - if a socket error
-        occurs, the socket is silently closed and then reopened on the next
-        logging call.
-        """
-        logging.Handler.__init__(self)
-        self.host = host
-        self.port = port
-        if port is None:
-            self.address = host
-        else:
-            self.address = (host, port)
-        self.sock = None
-        self.closeOnError = False
-        self.retryTime = None
-        #
-        # Exponential backoff parameters.
-        #
-        self.retryStart = 1.0
-        self.retryMax = 30.0
-        self.retryFactor = 2.0
-
-    def makeSocket(self, timeout=1):
-        """
-        A factory method which allows subclasses to define the precise
-        type of socket they want.
-        """
-        if self.port is not None:
-            result = socket.create_connection(self.address, timeout=timeout)
-        else:
-            result = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
-            result.settimeout(timeout)
-            try:
-                result.connect(self.address)
-            except OSError:
-                result.close()  # Issue 19182
-                raise
-        return result
-
-    def createSocket(self):
-        """
-        Try to create a socket, using an exponential backoff with
-        a max retry time. Thanks to Robert Olson for the original patch
-        (SF #815911) which has been slightly refactored.
-        """
-        now = time.time()
-        # Either retryTime is None, in which case this
-        # is the first time back after a disconnect, or
-        # we've waited long enough.
-        if self.retryTime is None:
-            attempt = True
-        else:
-            attempt = (now >= self.retryTime)
-        if attempt:
-            try:
-                self.sock = self.makeSocket()
-                self.retryTime = None # next time, no delay before trying
-            except OSError:
-                #Creation failed, so set the retry time and return.
-                if self.retryTime is None:
-                    self.retryPeriod = self.retryStart
-                else:
-                    self.retryPeriod = self.retryPeriod * self.retryFactor
-                    if self.retryPeriod > self.retryMax:
-                        self.retryPeriod = self.retryMax
-                self.retryTime = now + self.retryPeriod
-
-    def send(self, s):
-        """
-        Send a pickled string to the socket.
-
-        This function allows for partial sends which can happen when the
-        network is busy.
-        """
-        if self.sock is None:
-            self.createSocket()
-        #self.sock can be None either because we haven't reached the retry
-        #time yet, or because we have reached the retry time and retried,
-        #but are still unable to connect.
-        if self.sock:
-            try:
-                self.sock.sendall(s)
-            except OSError: #pragma: no cover
-                self.sock.close()
-                self.sock = None  # so we can call createSocket next time
-
-    def makePickle(self, record):
-        """
-        Pickles the record in binary format with a length prefix, and
-        returns it ready for transmission across the socket.
-        """
-        ei = record.exc_info
-        if ei:
-            # just to get traceback text into record.exc_text ...
-            dummy = self.format(record)
-        # See issue #14436: If msg or args are objects, they may not be
-        # available on the receiving end. So we convert the msg % args
-        # to a string, save it as msg and zap the args.
-        d = dict(record.__dict__)
-        d['msg'] = record.getMessage()
-        d['args'] = None
-        d['exc_info'] = None
-        s = pickle.dumps(d, 1)
-        slen = struct.pack(">L", len(s))
-        return slen + s
-
-    def handleError(self, record):
-        """
-        Handle an error during logging.
-
-        An error has occurred during logging. Most likely cause -
-        connection lost. Close the socket so that we can retry on the
-        next event.
-        """
-        if self.closeOnError and self.sock:
-            self.sock.close()
-            self.sock = None        #try to reconnect next time
-        else:
-            logging.Handler.handleError(self, record)
-
-    def emit(self, record):
-        """
-        Emit a record.
-
-        Pickles the record and writes it to the socket in binary format.
-        If there is an error with the socket, silently drop the packet.
-        If there was a problem with the socket, re-establishes the
-        socket.
-        """
-        try:
-            s = self.makePickle(record)
-            self.send(s)
-        except Exception:
-            self.handleError(record)
-
-    def close(self):
-        """
-        Closes the socket.
-        """
-        self.acquire()
-        try:
-            sock = self.sock
-            if sock:
-                self.sock = None
-                sock.close()
-            logging.Handler.close(self)
-        finally:
-            self.release()
-
-class DatagramHandler(SocketHandler):
-    """
-    A handler class which writes logging records, in pickle format, to
-    a datagram socket.  The pickle which is sent is that of the LogRecord's
-    attribute dictionary (__dict__), so that the receiver does not need to
-    have the logging module installed in order to process the logging event.
-
-    To unpickle the record at the receiving end into a LogRecord, use the
-    makeLogRecord function.
-
-    """
-    def __init__(self, host, port):
-        """
-        Initializes the handler with a specific host address and port.
-        """
-        SocketHandler.__init__(self, host, port)
-        self.closeOnError = False
-
-    def makeSocket(self):
-        """
-        The factory method of SocketHandler is here overridden to create
-        a UDP socket (SOCK_DGRAM).
-        """
-        if self.port is None:
-            family = socket.AF_UNIX
-        else:
-            family = socket.AF_INET
-        s = socket.socket(family, socket.SOCK_DGRAM)
-        return s
-
-    def send(self, s):
-        """
-        Send a pickled string to a socket.
-
-        This function no longer allows for partial sends which can happen
-        when the network is busy - UDP does not guarantee delivery and
-        can deliver packets out of sequence.
-        """
-        if self.sock is None:
-            self.createSocket()
-        self.sock.sendto(s, self.address)
-
-class SysLogHandler(logging.Handler):
-    """
-    A handler class which sends formatted logging records to a syslog
-    server. Based on Sam Rushing's syslog module:
-    http://www.nightmare.com/squirl/python-ext/misc/syslog.py
-    Contributed by Nicolas Untz (after which minor refactoring changes
-    have been made).
-    """
-
-    # from <linux/sys/syslog.h>:
-    # ======================================================================
-    # priorities/facilities are encoded into a single 32-bit quantity, where
-    # the bottom 3 bits are the priority (0-7) and the top 28 bits are the
-    # facility (0-big number). Both the priorities and the facilities map
-    # roughly one-to-one to strings in the syslogd(8) source code.  This
-    # mapping is included in this file.
-    #
-    # priorities (these are ordered)
-
-    LOG_EMERG     = 0       #  system is unusable
-    LOG_ALERT     = 1       #  action must be taken immediately
-    LOG_CRIT      = 2       #  critical conditions
-    LOG_ERR       = 3       #  error conditions
-    LOG_WARNING   = 4       #  warning conditions
-    LOG_NOTICE    = 5       #  normal but significant condition
-    LOG_INFO      = 6       #  informational
-    LOG_DEBUG     = 7       #  debug-level messages
-
-    #  facility codes
-    LOG_KERN      = 0       #  kernel messages
-    LOG_USER      = 1       #  random user-level messages
-    LOG_MAIL      = 2       #  mail system
-    LOG_DAEMON    = 3       #  system daemons
-    LOG_AUTH      = 4       #  security/authorization messages
-    LOG_SYSLOG    = 5       #  messages generated internally by syslogd
-    LOG_LPR       = 6       #  line printer subsystem
-    LOG_NEWS      = 7       #  network news subsystem
-    LOG_UUCP      = 8       #  UUCP subsystem
-    LOG_CRON      = 9       #  clock daemon
-    LOG_AUTHPRIV  = 10      #  security/authorization messages (private)
-    LOG_FTP       = 11      #  FTP daemon
-
-    #  other codes through 15 reserved for system use
-    LOG_LOCAL0    = 16      #  reserved for local use
-    LOG_LOCAL1    = 17      #  reserved for local use
-    LOG_LOCAL2    = 18      #  reserved for local use
-    LOG_LOCAL3    = 19      #  reserved for local use
-    LOG_LOCAL4    = 20      #  reserved for local use
-    LOG_LOCAL5    = 21      #  reserved for local use
-    LOG_LOCAL6    = 22      #  reserved for local use
-    LOG_LOCAL7    = 23      #  reserved for local use
-
-    priority_names = {
-        "alert":    LOG_ALERT,
-        "crit":     LOG_CRIT,
-        "critical": LOG_CRIT,
-        "debug":    LOG_DEBUG,
-        "emerg":    LOG_EMERG,
-        "err":      LOG_ERR,
-        "error":    LOG_ERR,        #  DEPRECATED
-        "info":     LOG_INFO,
-        "notice":   LOG_NOTICE,
-        "panic":    LOG_EMERG,      #  DEPRECATED
-        "warn":     LOG_WARNING,    #  DEPRECATED
-        "warning":  LOG_WARNING,
-        }
-
-    facility_names = {
-        "auth":     LOG_AUTH,
-        "authpriv": LOG_AUTHPRIV,
-        "cron":     LOG_CRON,
-        "daemon":   LOG_DAEMON,
-        "ftp":      LOG_FTP,
-        "kern":     LOG_KERN,
-        "lpr":      LOG_LPR,
-        "mail":     LOG_MAIL,
-        "news":     LOG_NEWS,
-        "security": LOG_AUTH,       #  DEPRECATED
-        "syslog":   LOG_SYSLOG,
-        "user":     LOG_USER,
-        "uucp":     LOG_UUCP,
-        "local0":   LOG_LOCAL0,
-        "local1":   LOG_LOCAL1,
-        "local2":   LOG_LOCAL2,
-        "local3":   LOG_LOCAL3,
-        "local4":   LOG_LOCAL4,
-        "local5":   LOG_LOCAL5,
-        "local6":   LOG_LOCAL6,
-        "local7":   LOG_LOCAL7,
-        }
-
-    #The map below appears to be trivially lowercasing the key. However,
-    #there's more to it than meets the eye - in some locales, lowercasing
-    #gives unexpected results. See SF #1524081: in the Turkish locale,
-    #"INFO".lower() != "info"
-    priority_map = {
-        "DEBUG" : "debug",
-        "INFO" : "info",
-        "WARNING" : "warning",
-        "ERROR" : "error",
-        "CRITICAL" : "critical"
-    }
-
-    def __init__(self, address=('localhost', SYSLOG_UDP_PORT),
-                 facility=LOG_USER, socktype=None):
-        """
-        Initialize a handler.
-
-        If address is specified as a string, a UNIX socket is used. To log to a
-        local syslogd, "SysLogHandler(address="/dev/log")" can be used.
-        If facility is not specified, LOG_USER is used. If socktype is
-        specified as socket.SOCK_DGRAM or socket.SOCK_STREAM, that specific
-        socket type will be used. For Unix sockets, you can also specify a
-        socktype of None, in which case socket.SOCK_DGRAM will be used, falling
-        back to socket.SOCK_STREAM.
-        """
-        logging.Handler.__init__(self)
-
-        self.address = address
-        self.facility = facility
-        self.socktype = socktype
-
-        if isinstance(address, str):
-            self.unixsocket = True
-            self._connect_unixsocket(address)
-        else:
-            self.unixsocket = False
-            if socktype is None:
-                socktype = socket.SOCK_DGRAM
-            self.socket = socket.socket(socket.AF_INET, socktype)
-            if socktype == socket.SOCK_STREAM:
-                self.socket.connect(address)
-            self.socktype = socktype
-        self.formatter = None
-
-    def _connect_unixsocket(self, address):
-        use_socktype = self.socktype
-        if use_socktype is None:
-            use_socktype = socket.SOCK_DGRAM
-        self.socket = socket.socket(socket.AF_UNIX, use_socktype)
-        try:
-            self.socket.connect(address)
-            # it worked, so set self.socktype to the used type
-            self.socktype = use_socktype
-        except OSError:
-            self.socket.close()
-            if self.socktype is not None:
-                # user didn't specify falling back, so fail
-                raise
-            use_socktype = socket.SOCK_STREAM
-            self.socket = socket.socket(socket.AF_UNIX, use_socktype)
-            try:
-                self.socket.connect(address)
-                # it worked, so set self.socktype to the used type
-                self.socktype = use_socktype
-            except OSError:
-                self.socket.close()
-                raise
-
-    def encodePriority(self, facility, priority):
-        """
-        Encode the facility and priority. You can pass in strings or
-        integers - if strings are passed, the facility_names and
-        priority_names mapping dictionaries are used to convert them to
-        integers.
-        """
-        if isinstance(facility, str):
-            facility = self.facility_names[facility]
-        if isinstance(priority, str):
-            priority = self.priority_names[priority]
-        return (facility << 3) | priority
-
-    def close (self):
-        """
-        Closes the socket.
-        """
-        self.acquire()
-        try:
-            self.socket.close()
-            logging.Handler.close(self)
-        finally:
-            self.release()
-
-    def mapPriority(self, levelName):
-        """
-        Map a logging level name to a key in the priority_names map.
-        This is useful in two scenarios: when custom levels are being
-        used, and in the case where you can't do a straightforward
-        mapping by lowercasing the logging level name because of locale-
-        specific issues (see SF #1524081).
-        """
-        return self.priority_map.get(levelName, "warning")
-
-    ident = ''          # prepended to all messages
-    append_nul = True   # some old syslog daemons expect a NUL terminator
-
-    def emit(self, record):
-        """
-        Emit a record.
-
-        The record is formatted, and then sent to the syslog server. If
-        exception information is present, it is NOT sent to the server.
-        """
-        try:
-            msg = self.format(record)
-            if self.ident:
-                msg = self.ident + msg
-            if self.append_nul:
-                msg += '\000'
-
-            # We need to convert record level to lowercase, maybe this will
-            # change in the future.
-            prio = '<%d>' % self.encodePriority(self.facility,
-                                                self.mapPriority(record.levelname))
-            prio = prio.encode('utf-8')
-            # Message is a string. Convert to bytes as required by RFC 5424
-            msg = msg.encode('utf-8')
-            msg = prio + msg
-            if self.unixsocket:
-                try:
-                    self.socket.send(msg)
-                except OSError:
-                    self.socket.close()
-                    self._connect_unixsocket(self.address)
-                    self.socket.send(msg)
-            elif self.socktype == socket.SOCK_DGRAM:
-                self.socket.sendto(msg, self.address)
-            else:
-                self.socket.sendall(msg)
-        except Exception:
-            self.handleError(record)
-
-class SMTPHandler(logging.Handler):
-    """
-    A handler class which sends an SMTP email for each logging event.
-    """
-    def __init__(self, mailhost, fromaddr, toaddrs, subject,
-                 credentials=None, secure=None, timeout=5.0):
-        """
-        Initialize the handler.
-
-        Initialize the instance with the from and to addresses and subject
-        line of the email. To specify a non-standard SMTP port, use the
-        (host, port) tuple format for the mailhost argument. To specify
-        authentication credentials, supply a (username, password) tuple
-        for the credentials argument. To specify the use of a secure
-        protocol (TLS), pass in a tuple for the secure argument. This will
-        only be used when authentication credentials are supplied. The tuple
-        will be either an empty tuple, or a single-value tuple with the name
-        of a keyfile, or a 2-value tuple with the names of the keyfile and
-        certificate file. (This tuple is passed to the `starttls` method).
-        A timeout in seconds can be specified for the SMTP connection (the
-        default is one second).
-        """
-        logging.Handler.__init__(self)
-        if isinstance(mailhost, (list, tuple)):
-            self.mailhost, self.mailport = mailhost
-        else:
-            self.mailhost, self.mailport = mailhost, None
-        if isinstance(credentials, (list, tuple)):
-            self.username, self.password = credentials
-        else:
-            self.username = None
-        self.fromaddr = fromaddr
-        if isinstance(toaddrs, str):
-            toaddrs = [toaddrs]
-        self.toaddrs = toaddrs
-        self.subject = subject
-        self.secure = secure
-        self.timeout = timeout
-
-    def getSubject(self, record):
-        """
-        Determine the subject for the email.
-
-        If you want to specify a subject line which is record-dependent,
-        override this method.
-        """
-        return self.subject
-
-    def emit(self, record):
-        """
-        Emit a record.
-
-        Format the record and send it to the specified addressees.
-        """
-        try:
-            import smtplib
-            from email.message import EmailMessage
-            import email.utils
-
-            port = self.mailport
-            if not port:
-                port = smtplib.SMTP_PORT
-            smtp = smtplib.SMTP(self.mailhost, port, timeout=self.timeout)
-            msg = EmailMessage()
-            msg['From'] = self.fromaddr
-            msg['To'] = ','.join(self.toaddrs)
-            msg['Subject'] = self.getSubject(record)
-            msg['Date'] = email.utils.localtime()
-            msg.set_content(self.format(record))
-            if self.username:
-                if self.secure is not None:
-                    smtp.ehlo()
-                    smtp.starttls(*self.secure)
-                    smtp.ehlo()
-                smtp.login(self.username, self.password)
-            smtp.send_message(msg)
-            smtp.quit()
-        except Exception:
-            self.handleError(record)
-
-class NTEventLogHandler(logging.Handler):
-    """
-    A handler class which sends events to the NT Event Log. Adds a
-    registry entry for the specified application name. If no dllname is
-    provided, win32service.pyd (which contains some basic message
-    placeholders) is used. Note that use of these placeholders will make
-    your event logs big, as the entire message source is held in the log.
-    If you want slimmer logs, you have to pass in the name of your own DLL
-    which contains the message definitions you want to use in the event log.
-    """
-    def __init__(self, appname, dllname=None, logtype="Application"):
-        logging.Handler.__init__(self)
-        try:
-            import win32evtlogutil, win32evtlog
-            self.appname = appname
-            self._welu = win32evtlogutil
-            if not dllname:
-                dllname = os.path.split(self._welu.__file__)
-                dllname = os.path.split(dllname[0])
-                dllname = os.path.join(dllname[0], r'win32service.pyd')
-            self.dllname = dllname
-            self.logtype = logtype
-            self._welu.AddSourceToRegistry(appname, dllname, logtype)
-            self.deftype = win32evtlog.EVENTLOG_ERROR_TYPE
-            self.typemap = {
-                logging.DEBUG   : win32evtlog.EVENTLOG_INFORMATION_TYPE,
-                logging.INFO    : win32evtlog.EVENTLOG_INFORMATION_TYPE,
-                logging.WARNING : win32evtlog.EVENTLOG_WARNING_TYPE,
-                logging.ERROR   : win32evtlog.EVENTLOG_ERROR_TYPE,
-                logging.CRITICAL: win32evtlog.EVENTLOG_ERROR_TYPE,
-         }
-        except ImportError:
-            print("The Python Win32 extensions for NT (service, event "\
-                        "logging) appear not to be available.")
-            self._welu = None
-
-    def getMessageID(self, record):
-        """
-        Return the message ID for the event record. If you are using your
-        own messages, you could do this by having the msg passed to the
-        logger being an ID rather than a formatting string. Then, in here,
-        you could use a dictionary lookup to get the message ID. This
-        version returns 1, which is the base message ID in win32service.pyd.
-        """
-        return 1
-
-    def getEventCategory(self, record):
-        """
-        Return the event category for the record.
-
-        Override this if you want to specify your own categories. This version
-        returns 0.
-        """
-        return 0
-
-    def getEventType(self, record):
-        """
-        Return the event type for the record.
-
-        Override this if you want to specify your own types. This version does
-        a mapping using the handler's typemap attribute, which is set up in
-        __init__() to a dictionary which contains mappings for DEBUG, INFO,
-        WARNING, ERROR and CRITICAL. If you are using your own levels you will
-        either need to override this method or place a suitable dictionary in
-        the handler's typemap attribute.
-        """
-        return self.typemap.get(record.levelno, self.deftype)
-
-    def emit(self, record):
-        """
-        Emit a record.
-
-        Determine the message ID, event category and event type. Then
-        log the message in the NT event log.
-        """
-        if self._welu:
-            try:
-                id = self.getMessageID(record)
-                cat = self.getEventCategory(record)
-                type = self.getEventType(record)
-                msg = self.format(record)
-                self._welu.ReportEvent(self.appname, id, cat, type, [msg])
-            except Exception:
-                self.handleError(record)
-
-    def close(self):
-        """
-        Clean up this handler.
-
-        You can remove the application name from the registry as a
-        source of event log entries. However, if you do this, you will
-        not be able to see the events as you intended in the Event Log
-        Viewer - it needs to be able to access the registry to get the
-        DLL name.
-        """
-        #self._welu.RemoveSourceFromRegistry(self.appname, self.logtype)
-        logging.Handler.close(self)
-
-class HTTPHandler(logging.Handler):
-    """
-    A class which sends records to a Web server, using either GET or
-    POST semantics.
-    """
-    def __init__(self, host, url, method="GET", secure=False, credentials=None,
-                 context=None):
-        """
-        Initialize the instance with the host, the request URL, and the method
-        ("GET" or "POST")
-        """
-        logging.Handler.__init__(self)
-        method = method.upper()
-        if method not in ["GET", "POST"]:
-            raise ValueError("method must be GET or POST")
-        if not secure and context is not None:
-            raise ValueError("context parameter only makes sense "
-                             "with secure=True")
-        self.host = host
-        self.url = url
-        self.method = method
-        self.secure = secure
-        self.credentials = credentials
-        self.context = context
-
-    def mapLogRecord(self, record):
-        """
-        Default implementation of mapping the log record into a dict
-        that is sent as the CGI data. Overwrite in your class.
-        Contributed by Franz Glasner.
-        """
-        return record.__dict__
-
-    def emit(self, record):
-        """
-        Emit a record.
-
-        Send the record to the Web server as a percent-encoded dictionary
-        """
-        try:
-            import http.client, urllib.parse
-            host = self.host
-            if self.secure:
-                h = http.client.HTTPSConnection(host, context=self.context)
-            else:
-                h = http.client.HTTPConnection(host)
-            url = self.url
-            data = urllib.parse.urlencode(self.mapLogRecord(record))
-            if self.method == "GET":
-                if (url.find('?') >= 0):
-                    sep = '&'
-                else:
-                    sep = '?'
-                url = url + "%c%s" % (sep, data)
-            h.putrequest(self.method, url)
-            # support multiple hosts on one IP address...
-            # need to strip optional :port from host, if present
-            i = host.find(":")
-            if i >= 0:
-                host = host[:i]
-            h.putheader("Host", host)
-            if self.method == "POST":
-                h.putheader("Content-type",
-                            "application/x-www-form-urlencoded")
-                h.putheader("Content-length", str(len(data)))
-            if self.credentials:
-                import base64
-                s = ('u%s:%s' % self.credentials).encode('utf-8')
-                s = 'Basic ' + base64.b64encode(s).strip()
-                h.putheader('Authorization', s)
-            h.endheaders()
-            if self.method == "POST":
-                h.send(data.encode('utf-8'))
-            h.getresponse()    #can't do anything with the result
-        except Exception:
-            self.handleError(record)
-
 class BufferingHandler(logging.Handler):
     """
   A handler class which buffers logging records in memory. Whenever each
@@ -1284,181 +519,4 @@
                 self.release()
 
 
-class QueueHandler(logging.Handler):
-    """
-    This handler sends events to a queue. Typically, it would be used together
-    with a multiprocessing Queue to centralise logging to file in one process
-    (in a multi-process application), so as to avoid file write contention
-    between processes.
-
-    This code is new in Python 3.2, but this class can be copy pasted into
-    user code for use with earlier Python versions.
-    """
-
-    def __init__(self, queue):
-        """
-        Initialise an instance, using the passed queue.
-        """
-        logging.Handler.__init__(self)
-        self.queue = queue
-
-    def enqueue(self, record):
-        """
-        Enqueue a record.
-
-        The base implementation uses put_nowait. You may want to override
-        this method if you want to use blocking, timeouts or custom queue
-        implementations.
-        """
-        self.queue.put_nowait(record)
-
-    def prepare(self, record):
-        """
-        Prepares a record for queuing. The object returned by this method is
-        enqueued.
-
-        The base implementation formats the record to merge the message
-        and arguments, and removes unpickleable items from the record
-        in-place.
-
-        You might want to override this method if you want to convert
-        the record to a dict or JSON string, or send a modified copy
-        of the record while leaving the original intact.
-        """
-        # The format operation gets traceback text into record.exc_text
-        # (if there's exception data), and also puts the message into
-        # record.message. We can then use this to replace the original
-        # msg + args, as these might be unpickleable. We also zap the
-        # exc_info attribute, as it's no longer needed and, if not None,
-        # will typically not be pickleable.
-        self.format(record)
-        record.msg = record.message
-        record.args = None
-        record.exc_info = None
-        return record
-
-    def emit(self, record):
-        """
-        Emit a record.
-
-        Writes the LogRecord to the queue, preparing it for pickling first.
-        """
-        try:
-            self.enqueue(self.prepare(record))
-        except Exception:
-            self.handleError(record)
-
-if threading:
-    class QueueListener(object):
-        """
-        This class implements an internal threaded listener which watches for
-        LogRecords being added to a queue, removes them and passes them to a
-        list of handlers for processing.
-        """
-        _sentinel = None
-
-        def __init__(self, queue, *handlers):
-            """
-            Initialise an instance with the specified queue and
-            handlers.
-            """
-            self.queue = queue
-            self.handlers = handlers
-            self._stop = threading.Event()
-            self._thread = None
-
-        def dequeue(self, block):
-            """
-            Dequeue a record and return it, optionally blocking.
-
-            The base implementation uses get. You may want to override this method
-            if you want to use timeouts or work with custom queue implementations.
-            """
-            return self.queue.get(block)
-
-        def start(self):
-            """
-            Start the listener.
-
-            This starts up a background thread to monitor the queue for
-            LogRecords to process.
-            """
-            self._thread = t = threading.Thread(target=self._monitor)
-            t.setDaemon(True)
-            t.start()
-
-        def prepare(self , record):
-            """
-            Prepare a record for handling.
-
-            This method just returns the passed-in record. You may want to
-            override this method if you need to do any custom marshalling or
-            manipulation of the record before passing it to the handlers.
-            """
-            return record
-
-        def handle(self, record):
-            """
-            Handle a record.
-
-            This just loops through the handlers offering them the record
-            to handle.
-            """
-            record = self.prepare(record)
-            for handler in self.handlers:
-                handler.handle(record)
-
-        def _monitor(self):
-            """
-            Monitor the queue for records, and ask the handler
-            to deal with them.
-
-            This method runs on a separate, internal thread.
-            The thread will terminate if it sees a sentinel object in the queue.
-            """
-            q = self.queue
-            has_task_done = hasattr(q, 'task_done')
-            while not self._stop.isSet():
-                try:
-                    record = self.dequeue(True)
-                    if record is self._sentinel:
-                        break
-                    self.handle(record)
-                    if has_task_done:
-                        q.task_done()
-                except queue.Empty:
-                    pass
-            # There might still be records in the queue.
-            while True:
-                try:
-                    record = self.dequeue(False)
-                    if record is self._sentinel:
-                        break
-                    self.handle(record)
-                    if has_task_done:
-                        q.task_done()
-                except queue.Empty:
-                    break
-
-        def enqueue_sentinel(self):
-            """
-            This is used to enqueue the sentinel record.
-
-            The base implementation uses put_nowait. You may want to override this
-            method if you want to use timeouts or work with custom queue
-            implementations.
-            """
-            self.queue.put_nowait(self._sentinel)
-
-        def stop(self):
-            """
-            Stop the listener.
-
-            This asks the thread to terminate, and then waits for it to do so.
-            Note that if you don't call this before your application exits, there
-            may be some records still left on the queue, which won't be processed.
-            """
-            self._stop.set()
-            self.enqueue_sentinel()
-            self._thread.join()
-            self._thread = None
+